本篇笔记介绍请求缓存，涉及到：cookie、cache-control、expires、Etags、Last-modify等。

缓存（Cache），指的是可以快速访问的副本资源。在学习缓存之前，先思考几个问题：

* 缓存有哪些种类，能解决什么问题？
* 在Web请求的哪些流程或节点需要用到缓存？
* 什么资源适合缓存？
* 如何更新缓存，保持同源资源一致？

#### 缓存的种类和作用

Web访问的重要课题之一就是响应和访问速度，而缓存机制就是提升响应速度的重要策略。良好的缓存策略不仅能减少海量请求带来的网络带宽消耗，缓解服务器压力，更为重要的是能加速客户端的资源获取速度，直接提升页面打开速度。

从请求的全部流程看，缓存分为：浏览器本地缓存、HTTP缓存、CDN缓存、数据库缓存等等。

CDN缓存和数据库缓存在对应知识的笔记会单独讲解到，这边笔记主要学习的是HTTP缓存策略。

#### 什么资源适合缓存

理论上，所有的静态资源都应该缓存，只不过依据资源的大小、修改频率需要不同的缓存策略。

#### HTTP缓存机制

报文指的是客户端和服务器间通信时发送和响应的数据块，依据发送源分为请求报文（request）和响应报文（response）。报文分为首部（header）和主体部分（body）：首部携带缓存相关规则信息、主体包含请求传输的内容。

假定三个主体：客户端（发起请求）——&gt; 缓存数据库（缓存资源）——&gt;服务器（源资源库）。

先看看涉及到的报头规则：![](/assets/报头规则)

**有两个名词了解下：**

新鲜度：指的是缓存资源的过期状态。缓存资源有通过expires或者Cache-Control：max-age设置了缓存的过期时间，在这个时间之前，缓存是“新鲜的”，客户端请求可以直接从缓存数据库拉取资源，不需再请求源服务器；在这个时间之后，缓存资源变得“陈旧”，客户端发出请求，缓存检索到资源已过期，缓存会先将此请求附加 If-Modified-Since 规则头，发给源服务器，目的是检查过期的缓存资源是否依然“新鲜”可用。源服务器验证后，若返回304（不返回实体信息），表明缓存依然“新鲜”；若返回200（携带新的信息），表明缓存已过期，返回和更新新的资源。

校验值：资源在服务器的唯一标识符，用作过期资源在源服务器身份的匹配校验。

**我们来看看最简单的请求-响应流程是怎样的：**

首次请求：

请求服务器，回传资源和响应规则并存储至缓存数据库，见下图：

![](/assets/cache4.png)

二次请求：

如果缓存依然“新鲜”，直接从缓存拿资源；

如果缓存“不新鲜”，请求源服务器做匹配，决定是否使用缓存资源。

见下图：![](/assets/cache7.png)从请求流程上看，第一次请求：

![](/assets/cache2.png)

重复请求：

![](/assets/cache3.png)

以上内容和图示参考自：[彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)



