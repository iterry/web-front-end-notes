这篇笔记介绍JS的执行机制——事件循环，会涉及到如下概念：单线程、异步回调、轮询、宏任务、微任务、事件队列等。

JS是一门单线程的语言，也就是说一个时间点只会执行一个任务。即使HTML5新增了Web Worker新标准，允许JS创建多个子线程，但Web Worker受限于主线程的控制管理，且不能操作DOM，常用的用途在大批量数据的计算处理上，本质上没有改变JS单线程的语言本质。

既然是单线程，所有的代码就需要从上到下按照顺序依次执行。如果前面的任务耗时长，后面的任务也必须排队等候。从业务场景看：图片加载、页面数据请求、音视频加载、大数据计算等耗时较长，如果一直等候这些任务加载或执行，页面的体验会有多糟糕！

为了解决这个问题，JS将代码任务分为两类：同步任务 和 异步任务。异步任务也成为异步回调。

如何创建异步任务呢？JS使用的是回调方法，或者称为回调函数。常见的回调包括：定时器、点击事件的执行事件、Ajax请求的success方法等等。

如何管理这两类任务的执行顺序呢？JS通过事件循环的执行机制来构建执行的并发模型。

通俗来讲，同步任务在主线程上排队、按照先后顺序依次执行；异步回调先不进入主线程，而是进入事件队列（Event queue），只有当主线程执行完毕，事件队列中的事件按照“先进先出”的原则才会进入主线程去执行。

如图所示：![](/assets/event_loop3.jpg)这是同步任务和异步任务的基本处理规则。

下面结合实例具体讲解这套基于“事件循环”的并发模型。

主线程运行的时候，形成执行栈（Stack），函数调用形成栈帧。同步任务按照代码的先后顺序依次进入执行栈

![](/assets/event_loop1.jpg)

![](/assets/event_loop2.jpg)

